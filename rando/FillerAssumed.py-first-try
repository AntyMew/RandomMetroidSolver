import random, logging

from rando.Filler import Filler
from rando.FillerRandom import FillerRandomItems, FrontFillerKickstart
from utils.parameters import infinity
from rando.Choice import ItemThenLocChoice
from graph.graph_access import GraphUtils
from rando.RandoServices import ComebackCheckType
from rando.ItemLocContainer import ItemLocation, getItemListStr
from utils.parameters import infinity

class ReverseFiller(Filler):
    def __init__(self, graphSettings, graph, restrictions, emptyContainer, endDate=infinity):
        super(ReverseFiller, self).__init__(graphSettings.startAP, graph, restrictions, emptyContainer, endDate)
        self.choice = ItemThenLocChoice(restrictions)
        self.stdStart = GraphUtils.isStandardStart(self.startAP)
        # always two front fill help to avoid ending issues with assumed fill
        self.nFrontFillSteps = max(graphSettings.getRandomFillHelp(), 2)
        self.errorMsg = ""

    def generateItems(self, condition=None, vcr=None):
        self.vcr = vcr
        self.initFiller()

        # first between 2 and 3 steps of frontfill
        self.log.debug("initial front fill start")
        frontFiller = FrontFillerKickstart(self.startAP, self.graph, self.restrictions, self.container)
        condition = frontFiller.createStepCountCondition(self.nFrontFillSteps)
        (stuck, itemLocations, progItems) = frontFiller.generateItems(condition)
        if stuck:
            self.errorMsg = "Stuck during initial front fill"
            if self.vcr != None:
                self.vcr.dump(reverse=True)
            return (stuck, self.container.itemLocations, self.getProgressionItemLocations())

        # assumed fill for important items
        self.log.debug("assumed fill start")
        assumedFiller = AssumedFiller(self.startAP, self.graph, self.restrictions, self.container, self.endDate)
        (stuck, itemLocs, prog) = assumedFiller.generateItems(vcr=self.vcr)
        if stuck:
            self.errorMsg = "Stuck during assumed fill"
            if self.vcr != None:
                self.vcr.dump(reverse=True)
            return (stuck, self.container.itemLocations, self.getProgressionItemLocations())

        # random fill no logic for remaining minors
        self.log.debug("final random fill start")
        randomFiller = FillerRandomItems(self.startAP, self.graph, self.restrictions, self.container, self.endDate)
        (stuck, itemLocs, prog) = randomFiller.generateItems(vcr=self.vcr)
        if stuck:
            self.errorMsg = "Stuck during final random fill"

        if self.vcr != None:
            self.vcr.dump(reverse=True)
        return (stuck, self.container.itemLocations, self.getProgressionItemLocations())

class AssumedFiller(Filler):
    def __init__(self, startAP, graph, restrictions, container, endDate=infinity):
        super(AssumedFiller, self).__init__(startAP, graph, restrictions, container, endDate)
        self.choice = ItemThenLocChoice(restrictions)
        self.stdStart = GraphUtils.isStandardStart(self.startAP)
        self.errorMsg = ""

    def generateItems(self, condition=None, vcr=None):
        self.vcr = vcr
        self.initFiller()

        alreadyPlacedItems = [il.Item for il in self.container.itemLocations]
        allItems = self.container.itemPool

        # get locations available with nothing, to fill them last
        firstLocations = self.services.currentLocations(self.startAP, self.container)

        # first collect mother brain
        for (boss, bossLocName) in [('MotherBrain', 'Mother Brain')]:
            bossItem = self.container.getItems(lambda it: it.Type == boss)
            bossLoc = self.container.getLocs(lambda loc: loc.Name == bossLocName)
            self.collect(ItemLocation(bossItem[0], bossLoc[0]))

        # split item pool for items in assumed fill and remaining items in random fill
        assumedItems = []
        requiredCount = {'Missile': 2, 'Super': 1, 'PowerBomb': 2, 'ETank': 4}
        currentCount = {'Missile': 0, 'Super': 0, 'PowerBomb': 0, 'ETank': 0}
        for item in allItems:
            if item.Type in currentCount and currentCount[item.Type] < requiredCount[item.Type]:
                assumedItems.append(item)
                currentCount[item.Type] += 1
            elif item.Type in ['Bomb', 'Charge', 'Ice', 'HiJump', 'SpeedBooster', 'Wave', 'Spazer', 'SpringBall', 'Varia', 'Plasma', 'Grapple', 'Morph', 'Gravity', 'XRayScope', 'SpaceJump', 'ScrewAttack', 'Kraid', 'Phantoon', 'Draygon', 'Ridley']:
                assumedItems.append(item)

        # TODO::choose morph loc first to forbid other items in it. TODO::handle early/late morph
        firstItemLocDict = self.services.getPossiblePlacementsWithoutItem(self.startAP, self.container, assumedItems, alreadyPlacedItems)
        # get item with the less possible locations
        minNbLocs = infinity
        for item, (locs, nbLocs) in firstItemLocDict.items():
            if len(locs) < minNbLocs:
                minNbLocs = len(locs)
                minItem = item

        # if some items can't be placed during assumed phase, put them in the 2nd phase
        for item, (locs, nbLocs) in firstItemLocDict.items():
            if len(locs) == 0:
                assumedItems.remove(item)
                self.log.debug("Move item {} to 2nd phase".format(item.Type))

        #morphLoc = random.choice(firstItemLocDict[morphItem][0])
        #self.log.debug("morph loc: {}".format(morphLoc.Name))

        for item in firstItemLocDict.keys():
            self.log.debug("first {} locs: {}".format(item.Type, len(firstItemLocDict[item][0])))

        # set start ap to mother brain as we're going in reverse from the end
        self.ap = 'Golden Four'

        while len(assumedItems) > 0:
            self.log.debug("remaining assumed items: {}: {}".format(len(assumedItems), getItemListStr(assumedItems)))

            # compute available locs without each item type
            itemLocDict = self.services.getPossiblePlacementsWithoutItem(self.ap, self.container, assumedItems, alreadyPlacedItems)

            # keep only items where there's enough locs after to put all assumed items
            filteredItemLocDict = {}
            onlyOneLocSet = set()
            for item, (locs, newNbAvailLocs) in itemLocDict.items():
                #if item != morphItem and morphLoc in locs:
                #    locs.remove(morphLoc)
                if item != minItem and len(assumedItems) > len(firstLocations):
                    for loc in firstLocations:
                        if loc in locs:
                            locs.remove(loc)
                if len(newNbAvailLocs) >= len(assumedItems):
                    filteredItemLocDict[item] = (locs, newNbAvailLocs)
                if len(locs) == 1 and item.Class != 'Boss':
                    # do not put an item in a loc where only one item can go, like morph
                    onlyOneLocSet.add(locs[0])

            if len(filteredItemLocDict) == 0:
                self.errorMsg = "No item with enough locations"

                if self.log.getEffectiveLevel() == logging.DEBUG:
                    for item, (locs, newNbAvailLocs) in itemLocDict.items():
                        self.log.debug("{}:".format(item.Type))
                        self.log.debug("  {} ({})".format([loc.Name for loc in locs], len(newNbAvailLocs)))
                        self.log.debug("  loc without item: {}".format([loc.Name for loc in newNbAvailLocs]))

                if self.vcr != None:
                    self.vcr.dump(reverse=True)
                return (True, self.container.itemLocations, self.getProgressionItemLocations())
            else:
                # first choose items with only one location possible
                singleLocItems = {}
                for item, (locs, newNbAvailLocs) in filteredItemLocDict.items():
                    if len(locs) == 1:
                        singleLocItems[item] = (locs, newNbAvailLocs)

                if len(singleLocItems) > 0:
                    item = random.choice(list(singleLocItems.keys()))
                    (locations, newNbAvailLocs) = singleLocItems[item]
                else:
                    item = random.choice(list(filteredItemLocDict.keys()))
                    (locations, newNbAvailLocs) = filteredItemLocDict[item]
                if len(onlyOneLocSet) > 0 and len(locations) > 1:
                    newLocations = []
                    for loc in locations:
                        if loc not in onlyOneLocSet:
                            newLocations.append(loc)
                        else:
                            self.log.debug("loc {} in onlyOneLocSet".format(loc.Name))
                    if len(newLocations) > 0:
                        locations = newLocations
            self.log.debug("item choosen: {}".format(item.Type))
            self.log.debug("locs for item: {}, newAvailLocs: {}".format(len(locations), [loc.Name for loc in newNbAvailLocs]))

            itemLoc = self.choice.chooseItemLoc({item: locations}, False)
            if itemLoc is None:
                self.errorMsg = "No location for item {}".format(item.Type)
                if self.vcr != None:
                    self.vcr.dump(reverse=True)
                return (True, self.container.itemLocations, self.getProgressionItemLocations())

            self.collect(itemLoc)
            assumedItems.remove(item)

        if self.vcr != None:
            self.vcr.dump(reverse=True)
        return (False, self.container.itemLocations, self.getProgressionItemLocations())
