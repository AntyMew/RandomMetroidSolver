
Design Graphe
*************

Notion de "GraphArea": correspond à l'area de l'item ou point d'accès
au sens graphe. Par ex Blue Brinstar est dans Crateria, Kraid dans
Norfair etc.

Noeuds du graphe: tous les points d'accès aux GraphArea. Le graph
complet est donc tous les "sous-graphes" correspondant à chaque
GraphArea, connectés avec les transitions (Vanilla ou Random).

Locations: une location est considérée accessible depuis un point
d'accès de sa GraphArea si elle fournit la fonction d'accès pour ce
point. Le résultat sera wand avec celui de la fonction spécifique à la
location elle-même (Available).

Donc vérifier si une location est accessible revient à vérifier si un
point d'accès de sa GraphArea permettant d'obtenir la location est
accessible, puis de faire wand avec la fonction Available de la
location. 

Chaque noeud du graph a aussi une fonction retournant un smbool
permettant de le traverser en cas de transition inter-areas. Le poids
d'une transition A->B est donc le poids de traversée de A+le poids de
la transition elle-même (wand).

Tous les sous-graphes intra-GraphArea peuvent être construits dès
maintenant.

Root node: 'Landing Site'

Généralités Algo (rando/solver)
*******************************

On se donne en entrée :

- les sous-graphes intra-GraphArea, avec les nodes et les fonctions
 donnant les transitions vers les autres nodes de leur GraphArea
- la liste des transitions inter-GraphArea: ce n'est *pas* le graphe
mais cela permettra de le constuire

On crée le graphe en fonction des items acquis. Partant du root node,
et du sous-graphe correspondant à la GraphArea Crateria on parcourt
les transitions afin de rajouter les noeuds et arêtes itérativement.

Noeuds: décrit plus haut
Arêtes: portent le poids de la transition calculé tq décrit ci-dessus

Le graphe sera recalculé à chaque item acquis, et de plus en plus
complexe. Le fait qu'il soit composé uniquement des endroits
accessibles permettra d'accélérer grandement le calcul des available
locations (surtout au début). Dans le cas du solver on ajoute toutes
les transitions dès que le smbool est True. Dans le cas du rando avec
max diff on contrôle la difficulté de la transition avant de
l'ajouter. 

On obtient ainsi un graphe potentiellement cyclique, ce qui ne
facilite pas le calcul de chemin du root node vers un autre node
quelconque.

=> on passe un coup d'algo Edmonds dessus afin d'en obtenir un
spanning tree à partir du root node. Ce spanning tree nous donne le
chemin optimal depuis le root node vers chaque autre node (il en
existera toujours un et un seul).

Obtention des availables :
**************************

(actuellement tout est porté par la fonction Available (et PostAvail)
de la location. On doit maintenant centraliser ce code afin d'y avoir
accès depuis le solver et le rando)

Pour chaque location: on parcourt tous les points d'accès qu'elle
fournit. Si le point d'accès est dans le graphe (donc accessible
depuis le root node), on wand le résultat de l'accès au point et de la
fonction Available.

On se retrouve ainsi avec un smbool d'accès pour chaque location et
l'algo rando/solver peut fonctionner comme avant.
