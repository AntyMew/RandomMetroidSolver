{{extend 'layout.html'}}

{{include 'solver_web/t_includes.html'}}

<title>Super Metroid VARIA Randomizer Tracker</title>

<style>
{{include 'solver_web/t_style.html'}}

.help {
    cursor: pointer;
    position: absolute;
    z-index: 2;
    width: 2.5%;
    height: 5%;
    top: 0%;
    left: 2.75%;
}
.titleItem {
    position: absolute;
    z-index: 2;
    width: 10%;
    height: 3.75%;
    top: 6%;
    left: 6%;
    color: #ffffff;
    font-size: 1.25vw;
    font-weight: bold;
}
.startItem {
    cursor: pointer;
    position: absolute;
    z-index: 2;
    width: 2.5%;
    height: 5%;
    top: 5.2%;
    left: 10.5%;
}
.repeatItem {
    cursor: pointer;
    position: absolute;
    z-index: 2;
    width: 2.5%;
    height: 5%;
    top: 5.2%;
    left: 13.25%;
}
.binItem {
    cursor: pointer;
    position: absolute;
    z-index: 2;
    width: 2.5%;
    height: 5%;
    top: 5.2%;
    left: 16%;
}

#titleAutoTracker {
    position: absolute;
    z-index: 2;
    width: 20%;
    height: 3.75%;
    top: 0%;
    left: 84.5%;
    color: #ffffff;
    font-size: 1.25vw;
    font-weight: bold;
}
#startStopAutoTracker {
    cursor: pointer;
    position: absolute;
    z-index: 2;
    width: 2.5%;
    height: 5%;
    top: 4%;
    left: 79%;
}
#statusAutoTracker {
    position: absolute;
    z-index: 2;
    width: 2.5%;
    height: 5%;
    top: 4%;
    left: 81.75%;
}
#helpAutoTracker {
    cursor: pointer;
    position: absolute;
    z-index: 2;
    width: 2.5%;
    height: 5%;
    top: 4%;
    left: 84.50%;
}
#logAutoTracker {
    position: absolute;
    z-index: 2;
    width: 12%;
    height: 16%;
    top: 4%;
    left: 88%;
    resize: none;
    font-size: 0.5vw;
}
#debugMap {
    position: absolute;
    top: 20%;
    left: 20%;
    border: 2px solid #666666;
    background-color: #000;
}
</style>

<script type="text/javascript">
var globalPlando = false;

function initCurMode() {
  document.getElementById("mode").value = "seedless";
  mode = "seedless";
}

{{include 'solver_web/t_js.html'}}

//-----------------------------------------------------------
// TUTORIAL

function startTheTour(step=-1) {
  // the tour tutorial
  var tour = new Tour({
    storage: false,
    steps: [{
      element: "#help",
      title: "VARIA Areas/Bosses & Items Tracker",
      content: "<h2 class=\"center\">Welcome to the VARIA Areas/Bosses & Items Tracker</h2><h4>Areas/Bosses Tracker</h4>\
<p>The Areas and Bosses Tracker allows you to track the connections between the areas and bosses portals.<br/>To use it, click on a portal <img src=\"/solver/static/images/portal.png\" alt=\"Portal\" style=\"width: 20px\">, it'll highlight it, then click on a second portal, it'll draw a line between the two portals with a random color.<br/>\
You can delete the latest added transition with the <img src=\"/solver/static/images/repeat.svg\" alt=\"Cancel Last\" style=\"width: 32px\"> button and all of them with the <img src=\"/solver/static/images/bin.svg\" alt=\"Remove all\" style=\"width: 32px\"> button.<br/>\
You can also click on the portal <img src=\"/solver/static/images/portal.png\" alt=\"Portal\" style=\"width: 20px\"> of an existing transition and click on the <img src=\"/solver/static/images/repeat.svg\" alt=\"Cancel Last\" style=\"width: 32px\"> button to delete it.<br/>\
Only the locations of connected areas/bosses are computed by the Items Tracker (as such if the ROM is not Areas/Bosses randomized the vanilla transitions will be automatically added).<br/>\
There's three portal types that you can't mix: Area portals: <img src=\"/solver/static/images/portal.png\" alt=\"Portal\" style=\"width: 20px\">, Boss portals: <img src=\"/solver/static/images/portal_boss.png\" alt=\"Boss Portal\" style=\"width: 20px\">, Escape portals: <img src=\"/solver/static/images/portal_escape.png\" alt=\"Escape Portal\" style=\"width: 20px\"> (active only in Area Plandomizer).<br/>\
The left Sand Hall door <img src=\"/solver/static/images/portal_maridia.png\" alt=\"Portal Maridia\" style=\"width: 20px\"> exits to below Botwoon Energy Tank room <img src=\"/solver/static/images/portal_maridia_area.png\" alt=\"Portal Maridia Area\" style=\"width: 20px\"> when area randomization is active (the blue door in West Sand Hall Tunnel has been greyed), it defaults to vanilla output otherwise <img src=\"/solver/static/images/portal_maridia_vanilla.png\" alt=\"Portal Maridia Vanilla\" style=\"width: 20px\">.</p>\
<h4>Items Tracker</h4>\
<p>The Items Tracker allows you to use the Solver in interactive mode.<br/>To use it, click on the <img src=\"/solver/static/images/play.svg\" alt=\"Start\" style=\"width: 32px\"> button to upload your ROM and choose your preset (like on the Solver page).<br/>Then the available locations will be displayed on the map, click on a location after you've collected the item of the location in the game, it'll update the next available locations.<br/>\
The color of the icon on the available locations matchs the difficulty to reach the location:\
<table><tr><td><img src=\"/solver/static/images/marker_easy.gif\" alt=\"easy\" style=\"width: 32px; background-color: #000;\"> easy</td><td><img src=\"/solver/static/images/marker_medium.gif\" alt=\"medium\" class=\"diffHelp\"> medium</td></td><td><img src=\"/solver/static/images/marker_hard.gif\" alt=\"hard\" class=\"diffHelp\"> hard</td><td><img src=\"/solver/static/images/marker_harder.gif\" alt=\"harder\" class=\"diffHelp\"> very hard</td><td><img src=\"/solver/static/images/marker_hardcore.gif\" alt=\"hardcore\" class=\"diffHelp\"> hardcore</td><td><img src=\"/solver/static/images/marker_mania.gif\" alt=\"mania\" class=\"diffHelp\"> mania</td><td colspan=\"3\"><img src=\"/solver/static/images/marker_break.png\" alt=\"break\" class=\"diffHelp\"> sequence break</td></tr></table>\
You can uncollect the item at a location by clicking on the location again.<br/>\
The locations not available are displayed with the Sequence Break icon, allowing you to collect them when you sequence break.<br/>When a location has been visited its icon displays the collected item: <img src=\"/solver/static/images/marker_visited_easy_Gravity.png\" alt=\"Visited\" style=\"width: 32px\"> or this if no item was found: <img src=\"/solver/static/images/marker_visited_easy.png\" alt=\"Visited\" style=\"width: 32px\">, one color for each difficulty.<br/>\
The locations availability are computed from the current access point which is displayed with this icon: <img src=\"/solver/static/images/gps.png\" alt=\"last access point\" style=\"width: 32px\"><br/>\
When overing the mouse cursor on an available location a tooltip is displayed with the location's name, the techniques and items used to access it from the current access point.<br/>\
The second green GPS icon displayed when overing on a location is the location's nearest access point, after collecting the item at the location the current access point will be updated to it.<br/>\
After the location has been visited only the collected item is displayed.</p>\
<h4>Doors Tracker</h4>\
<p>Colored doors are displayed on the map. If the seed is doors colors randomized then doors are initially white, you have to click on them to reveal their color to allow the tracker to traverse them. If the seed is not doors colors randomized then doors can't be clicked.</p>\
<h4>Touch screen tablette mode</h4>\
<p>You can use the tracker on your touch screen tablette without a ROM file, aka seed less mode, to start using it leave the \"Randomized Super Metroid ROM\" input empty after clicking on the <img src=\"/solver/static/images/play.svg\" alt=\"Start\" style=\"width: 32px\"> button.<br/>\
You can choose the start location to match the seed you're playing.<br/>\
Clicking on a location will set the Nothing item on it. To tell the tracker which item you collected in-game click on the inventory screen: +/- buttons and directly on items<br/><img src=\"/solver/static/images/background_seedless.png\"><br/>\
By default all the vanilla transitions are loaded, you can delete them with the <img src=\"/solver/static/images/bin.svg\" alt=\"Remove all\" style=\"width: 32px\"> button.</p>\
<h4>Race protected seeds</h4>\
You can load a race protected seed in the tracker, it'll use it to know if the seed has area/boss randomization, its patches, ... Then the tracker switchs to seedless mode to let you manage the inventory.\
<h4>Auto Save</h4>\
<p>The tracker feature an auto save functionnality, so you can do your seed in multiple seatings.<br/>The different status icons of the auto save:<table><tr><td><img src=\"/solver/static/images/refresh.svg\" style=\"width: 32px\"> Loading in progress</td><td><img src=\"/solver/static/images/checkmark.svg\" style=\"width: 32px\"> Save ok</td></tr><tr><td><img src=\"/solver/static/images/cloud_upload.png\" style=\"width: 32px\"> Upload in progress</td><td><img src=\"/solver/static/images/cloud_download.svg\" style=\"width: 32px\"> Download in progress</td></tr><tr><td colspan=\"2\"><img src=\"/solver/static/images/warning.svg\" style=\"width: 32px\"> Something wrong happened (try reloading the page)</td></tr></table></p><p>You can display this help again by clicking on the <img src=\"/solver/static/images/help.svg\" alt=\"help\" style=\"width: 32px\"> button.</p>\
<h4>Thanks to</h4>\
<p><ul><li>Animated location icons by Djlo</li><li>Location icons from Alli_Cat's <a href='https://github.com/allibear17/Super-Metroid-Location-Tracker' target=\"_blank\">Location Tracker</a></li><li>G4 sprite from Crossproduct's <a href=\"https://www.twitch.tv/crossproduct\" target=\"_blank\">smrandohelper</a></li><li>Action icons from <a href='https://dryicons.com/icon-packs/stylistica-icons-set' target=\"_blank\">Dryicons</a></li></ul></p>"
    }]
  });

  // Initialize the tour
  tour.init();

  // Start the tour
  if(step != -1) {
    tour.goTo(step);
  }
  tour.start();
}

var debug = false;
function onloadHook() {
}


// auto tracker
var socket;
// timeout to peek data
var timeout;
// timeout duration in ms
var waitingTime = 1000;

// first you open the socket,
// then you list the available devices,
// then you attach to the device and ask info to confirm attachment,
// then you can ask for data (main loop)
var stateEnum = {
    "opening": 1,
    "listing": 2,
    "infoing": 3,
    "looping": 4
}
var curState = 0;

// handle fragmented data reception
var askedDataSize = 0;
var receivedDataSize = 0;
var receivedData = [];
var transfertStart = 0;

// different data that we ask
var dataEnum = {
    "state": 1,
    "map": 2,
    "curMap": 3,
    "samus": 4
}
// 1. state:
// $0998: Game state
// $05D1: Debug. Debug mode. Set to [$80:8004] during boot / soft reset

// 2. map:
// CD52 -> D251: map tiles for: Crateria + Brinstar + Norfair + Wrecked Ship + Maridia

// 3. curmap:
// 07F7..08F6: map tiles for current area

// 4. samus:
// $0AF6: Samus X position (inside current screen)
// $0AFA: Samus Y position (inside current screen)
// 
// $079B: Room pointer
// $079F: Area index
// $07A1: Room X co-ordinate (on map)
// $07A3: Room Y co-ordinate (on map)
var dataToAsk = {
    1: [{"address": "F50998", "size": 0x2},
        {"address": "F505D1", "size": 0x2}],
    2: [{"address": "F5CD52", "size": 0x500}],
    3: [{"address": "F507F7", "size": 0x100}],
    4: [{"address": "F50AF6", "size": 0x2},
        {"address": "F50AFA", "size": 0x2},
        {"address": "F5079B", "size": 0x0a}]
}
var curDataState = 0;

// maps
var mapOffsetEnum = {
    "curMap": 0,
    "crateria": 0,
    "brinstar": 0x100,
    "norfair": 0x200,
    "wreckedShip": 0x300,
    "maridia": 0x400
}

// samus
var samusEnum = {
    "x": 0,
    "y": 2,
    "roomPointer": 4,
    "roomIndex": 6,
    "areaIndex": 8,
    "roomX": 10,
    "roomY": 12
}

// areas
var areaEnum = {
    0: "Crateria",
    1: "Brinstar",
    2: "Norfair",
    3: "Wrecked Ship",
    4: "Maridia",
    5: "Tourian",
    6: "Ceres",
    7: "Debug"
}
function resetLog() {
    document.getElementById("logAutoTracker").value = "";
}

function appendLog(msg) {
    console.log(msg);
    var txtArea = document.getElementById("logAutoTracker");
    txtArea.value +=  msg + '\r\n';

    // auto scroll to bottom
    txtArea.scrollTop = txtArea.scrollHeight;
}

function setAutoTrackerIcon(icon) {
  var names = ["statusOK", "statusKO", "statusLoad", "statusNA"];
  for(var i=0; i<names.length; i++) {
    if(names[i] == icon){
      document.getElementById(names[i]).style.display = "block";
    } else {
      document.getElementById(names[i]).style.display = "none";
    }
  }
}

function displayStopButton() {
    document.getElementById("stopAutoTracker").style.display = "block";
    document.getElementById("startAutoTracker").style.display = "none";
}

function displayStartButton() {
    document.getElementById("startAutoTracker").style.display = "block";
    document.getElementById("stopAutoTracker").style.display = "none";
}

function startAutoTracker() {
    if(loaded == false || webServInProgress == true || init == false) {
        return;
    }

    appendLog("\r\n\u2026 Starting Auto Tracker");
    // open websocket
    var url = 'ws://localhost:8080';
    socket = new WebSocket(url);
    socket.onopen = socketOnOpen;
    socket.onmessage = socketOnMessage;
    socket.onclose = socketOnClose;
    socket.onerror = socketOnError;

    // update state
    curState = stateEnum.opening;

    // update interface
    displayStopButton();
    setAutoTrackerIcon("statusLoad");
}

function closeSocket() {
    socket.close(1000);

    // update state
    curState = stateEnum.closing;

    // update interface
    setAutoTrackerIcon("statusLoad");
}

function stopAutoTracker() {
    if(loaded == false || webServInProgress == true || init == false) {
        return;
    }

    appendLog("\u2026 Stopping Auto Tracker");
    closeSocket();

    // update interface
    displayStartButton();
}

function socketOnOpen(e) {
    appendLog("\u2705 Connection established");
    // appendLog(" bufferedAmount: "+socket.bufferedAmount);
// Constant 	Value
// WebSocket.CONNECTING 	0
// WebSocket.OPEN 	1
// WebSocket.CLOSING 	2
// WebSocket.CLOSED 	3
    // appendLog(" readyState: "+socket.readyState);

    appendLog("\u2026 Asking Device List");
    sendAutoTrackerMessage({
        "Opcode" : "DeviceList",
        "Space" : "SNES"
    }, stateEnum.listing);
}

function socketOnMessage(event) {
    if(curState == stateEnum.looping) {
        socketOnLoopMessage(event);
    } else {
        socketOnInitMessage(event);
    }
}

function socketOnInitMessage(event) {
    var data = JSON.parse(event.data);
    var results = data["Results"];
    // appendLog(`Data received: ${results}`);
    setAutoTrackerIcon("statusOK");

    if(curState == stateEnum.listing) {
        if(results.length == 0) {
            appendLog("\u274C no device found");
            closeSocket();
        } else if(results.length > 1) {
            appendLog("\u274C too many devices found, please connect only one");
            closeSocket();
        } else {
            var device = results;
            appendLog(`\u2705 device found: ${device}`);

            appendLog("\u2026 Attaching to Device");
            sendAutoTrackerMessage({
                "Opcode" : "Attach",
                "Space" : "SNES",
                "Operands" : device
            }, stateEnum.infoing);

            // tell qusb our app name
            appendLog("\u2026 Send VARIA app name");
            sendAutoTrackerMessage({
                "Opcode" : "Name",
                "Space" : "SNES",
                "Operands": ["VARIA Tracker"]
            }, stateEnum.infoing);

            // send info command to validate attaching, we can send it right away as there's a queue in qusb
            appendLog("\u2026 Getting Device Info");
            sendAutoTrackerMessage({
                "Opcode" : "Info",
                "Space" : "SNES"
            }, stateEnum.infoing);

        }
    } else if(curState == stateEnum.infoing) {
        appendLog(`\u2705 info received: ${results}`);
        appendLog(`\u2705 device attached`);

        // start loop, update state
        curState = stateEnum.looping;

        // ask socket to return an arraybuffer instead of a blob
        socket.binaryType = "arraybuffer";

        // first data retrieval
        curDataState = dataEnum.state;
        askForData();
    } else {
        appendLog(`\u274C unknown receiving state ${curState}`);
        closeSocket();
    }
}

function socketOnLoopMessage(event) {
    setAutoTrackerIcon("statusOK");
    handleData(event.data);
}

function socketOnClose(event) {
    if (event.wasClean) {
        appendLog(`\u2705 Connection closed cleanly`);
        console.log(`socketOnClose clean: code=${event.code} reason=${event.reason}`);
    } else {
        // e.g. server process killed or network down
        // event.code is usually 1006 in this case
        appendLog('\u274C Connection died');
        console.log(`socketOnClose not clean: code=${event.code} reason=${event.reason}`);
    }
    // stop running timeout
    clearTimeout(timeout);

    // update state & interface
    cleanupBuffer();
    curState = stateEnum.closed;
    setAutoTrackerIcon("statusNA");
    displayStartButton();
}

function socketOnError(error) {
    appendLog("\u274C Connection error");

    // stop running timeout
    clearTimeout(timeout);

    // update state & interface
    cleanupBuffer();
    curState = stateEnum.closed;
    setAutoTrackerIcon("statusKO");
    displayStartButton();
}

// called to request datas from qusb
function askForData() {
    // check current state
    if(curState != stateEnum.looping) {
        appendLog(`\u274C Wrong state: ${curState}`);
        closeSocket();
    } else {
        var metadata = dataToAsk[curDataState];
        askedDataSize = 0;
        var ranges = [];

        for(var i=0; i<metadata.length; i++) {
            askedDataSize += metadata[i].size;
            ranges.push(metadata[i].address);
            ranges.push(metadata[i].size.toString(16));
        }

        console.log(`\u2026 Asking ${askedDataSize} bytes of Data`);

        transfertStart = Date.now();
        sendAutoTrackerMessage({
            "Opcode" : "GetAddress",
            "Space" : "SNES",
            "Operands": ranges
        }, stateEnum.looping);
        setAutoTrackerIcon("statusLoad");
    }
}

function readWord(array, addr) {
    return (array[addr+1]<<8) + array[addr];
}

function getGameStateName(gameStateCode) {
    switch(gameStateCode) {
        case '0': return "Reset/start";
        case '1': return "Opening. Cinematic";
        case '2': return "Game options menu";
        case '3': return "Nothing (RTS)";
        case '4': return "Save game menus";
        case '5': return "Loading game map view";
        case '6': return "Loading game data";
        case '7': return "Setting game up after loading the game";
        case '8': return "Main gameplay";
        case '9': return "Hit a door block";
        case 'a': return "Loading next room";
        case 'b': return "Loading next room";
        case 'c': return "Pausing, normal gameplay but darkening";
        case 'd': return "Pausing, loading pause screen";
        case 'e': return "Paused, loading pause screen";
        case 'f': return "Paused, map and item screens";
        case '10': return "Unpausing, loading normal gameplay";
        case '11': return "Unpausing, loading normal gameplay";
        case '12': return "Unpausing, normal gameplay but brightening";
        case '13': return "Samus ran out of health";
        case '14': return "Samus ran out of health, black out surroundings";
        case '15': return "Samus ran out of health, black out surroundings";
        case '16': return "Samus ran out of health, starting death animation";
        case '17': return "Samus ran out of health, flashing";
        case '18': return "Samus ran out of health, explosion";
        case '19': return "Samus ran out of health, black out (also cut to by time up death)";
        case '1a': return "Game over screen";
        case '1b': return "Reserve tanks auto";
        case '1c': return "Unused. Does JMP ($0DEA) ($0DEA is never set to a pointer)";
        case '1d': return "Debug game over menu (end/continue)";
        case '1e': return "Intro. Cinematic. Set up entirely new game with cutscenes";
        case '1f': return "Set up new game. Post-intro";
        case '20': return "Made it to Ceres elevator";
        case '21': return "Blackout from Ceres";
        case '22': return "Ceres goes boom, Samus goes to Zebes. Cinematic";
        case '23': return "Time up";
        case '24': return "Whiting out from time up";
        case '25': return "Ceres goes boom with Samus. Cinematic";
        case '26': return "Samus escapes from Zebes. Transition from main gameplay to ending and credits";
        case '27': return "Ending and credits. Cinematic";
        case '28': return "Transition to demo";
        case '29': return "Transition to demo";
        case '2a': return "Playing demo";
        case '2b': return "Transition from demo";
        case '2c': return "Transition from demo";
        default: return `Unkown game state (${gameStateCode})`;
    }
}

// managed data returned by qusb
function handleData(data) {
    var chunk = new Uint8Array(data);
    var chunkSize = chunk.length
    receivedDataSize += chunkSize;
    receivedData.push(chunk);
    console.log(`\u2026 get: ${chunkSize} (${receivedDataSize}/${askedDataSize})`);

    if(receivedDataSize >= askedDataSize) {
        // appendLog(`\u2705 All data received curDataState: ${curDataState}`);

        if(curDataState == dataEnum.state) {
            var duration = Date.now() - transfertStart;
            appendLog(`\u2705 State data received in ${duration}ms`);

            // we have only one chunk
            if(receivedData.length != 1) {
                // something is wrong
                appendLog("\u274C State data was received in more than one chunk");
                closeSocket();
            } else {
                var data = receivedData[0];

                // biggest valid game state
                var maxGameState = 0x2c;
                var mainGameplayState = 8;

                var gameState = readWord(data, 0x00);
                var gameStateName = getGameStateName(gameState.toString(16));
                // appendLog(`\u2026 Game state: ${gameStateName}`);

                var debugMode = readWord(data, 0x2);
                // appendLog(`\u2026 Debug Mode: ${debugMode}`);

                // check if game is running and is metroid
                if(debugMode == 0 && gameState < maxGameState) {
                    if(gameState == mainGameplayState) {
                        appendLog(`\u2705 Super Metroid gameplay state: ${gameStateName}`);
                        // ask map data
                        //askNextData(dataEnum.map, true);
                        askNextData(dataEnum.curMap, true);
                    } else {
                        appendLog(`\u231B Super Metroid other state: ${gameStateName}`);
                        askNextData(dataEnum.state, false);
                    }
                } else {
                    appendLog("\u231B Super Metroid is not running");
                    askNextData(dataEnum.state, false);
                }
            }
        } else if(curDataState == dataEnum.map) {
            var duration = Date.now() - transfertStart;
            appendLog(`\u2705 Map data received in ${duration}ms`);

            // TODO::extract the data we want from map data

            // concatenate all arrays
            var mapData = concatArrays(dataEnum.map);

            // display debug map for now
            displayDebugMap(mapData, mapOffsetEnum.crateria);

            // rearm timer for next data retrieval
            askNextData(dataEnum.state, false);
        } else if(curDataState == dataEnum.curMap) {
            var duration = Date.now() - transfertStart;
            appendLog(`\u2705 Current Map data received in ${duration}ms`);

            // TODO::extract the data we want from map data

            // concatenate all arrays
            var mapData = concatArrays(dataEnum.curMap);

            displayDebugMap(mapData, mapOffsetEnum.curMap);

            askNextData(dataEnum.samus, true);
        } else if(curDataState = dataEnum.samus) {
            var duration = Date.now() - transfertStart;
            appendLog(`\u2705 Samus data received in ${duration}ms`);

            // concatenate all arrays
            var samusData = concatArrays(dataEnum.samus);

            // extract data we need
            var samusX = readWord(samusData, samusEnum.x);
            var samusY = readWord(samusData, samusEnum.y);
            var roomPointer = readWord(samusData, samusEnum.roomPointer);
            var areaIndex = readWord(samusData, samusEnum.areaIndex);
            var roomX = readWord(samusData, samusEnum.roomX);
            var roomY = readWord(samusData, samusEnum.roomY);

            // compute (byte, bit) index in map data for current samus screen
            // Let
            //     x = [room X co-ordinate] + [$12] / 100h
            //     y = [room Y co-ordinate] + [$18] / 100h
            // Then
            //     $07FB + (y + (x & 20h)) * 4 + (x & 1Fh) / 8 |= 80h >> (x & 7)
            var x = roomX + Math.floor(samusX / 0x100);
            var y = roomY + Math.floor(samusY / 0x100);
            var byteIndex = (y + (x & 0x20)) * 4 + Math.floor((x & 0x1F) / 8);
            // first line of map is unused, so add 4 to ignore it (8 bytes per lines, but 4 in each page)
            byteIndex += 4;
            var bitMask = 0x80 >> (x & 7);
            // console.log(`cur byteIndex: ${byteIndex} bitMask: ${bitMask} room: ${roomPointer.toString(16)} area: ${areaEnum[areaIndex]}`);
            displaySamus(byteIndex, bitMask);

            // rearm timer for next data retrieval
            askNextData(dataEnum.state, false);
        }
    }
}

function concatArrays(dataType) {
    var metadata = dataToAsk[dataType];
    var dataSize = 0;
    for(var i=0; i<metadata.length; i++) {
        dataSize += metadata[i].size;
    }

    var data = new Uint8Array(dataSize);
    var curPos = 0;

    for(var i=0; i<receivedData.length; i++) {
        data.set(receivedData[i], curPos);
        curPos += receivedData[i].length;
    }

    return data;
}

function displayDebugMap(mapData, areaStart) {
    // display the map on canvas
    var canvas = document.getElementById('debugMap');
    var ctx = canvas.getContext('2d');

    // metroid map pink
    ctx.fillStyle = 'rgb(222, 57, 148)';

    // for each bit set in the map data display a 8x8 square on the map canvas
    var areaSize = 0x100;
    // 0x0: crateria ou current map
    // 0x100: brinstar
    // 0x200: norfair
    // 0x300: WS
    // 0x400: maridia
    var areaEnd = areaStart + areaSize;

    ctx.clearRect(0, 0, canvas.width, canvas.height);
    // squares we are drawing
    var width = 8;
    var height = 8;

    for(var i=areaStart; i<areaEnd; i++) {
        var b = mapData[i];
        if(b == 0) {
            continue;
        } else {
            var byteIndex = i - areaStart;
            for(var j=7; j>=0; j--) {
                if((b & 0x80) == 0x80) {
                    var bitMask = Math.pow(2, j);
                    var coords = getMapDisplayCoord(byteIndex, bitMask);
                    ctx.fillRect(coords[0], coords[1], width, height);
                }
                b = b << 1;
            }
        }
    }
}

function displaySamus(byteIndex, bitMask) {
    var canvas = document.getElementById('debugMap');
    var ctx = canvas.getContext('2d');

    // samus yellow
    ctx.fillStyle = 'rgb(255, 189, 3)';

    var width = 4;
    var height = 4;
    var coords = getMapDisplayCoord(byteIndex, bitMask);

    // add 2 to draw in the center of the map square
    ctx.fillRect(coords[0]+2, coords[1]+2, width, height);
}

function getMapDisplayCoord(byteIndex, bitMask) {
    // http://patrickjohnston.org/bank/90#fA8A6
    //
    // Map tiles explored (for current area). One bit per room.
    // Laid out like a 64x32 1bpp VRAM tilemap:
    //   2x1 pages of 32x32 map tiles (80h bytes per page, 4 bytes per row, 1 bit per tile),
    //   each byte is 8 map tiles where the most significant bit is the leftmost tile.
    //
    // Let
    //     x = [room X co-ordinate] + [$12] / 100h
    //     y = [room Y co-ordinate] + [$18] / 100h
    // Then
    //     $07FB + (y + (x & 20h)) * 4 + (x & 1Fh) / 8 |= 80h >> (x & 7)
    // are we in the first or second page

    // squares we are drawing
    var width = 8;
    var height = 8;

    var y = (byteIndex < 128) ? byteIndex : byteIndex - 128;
    // each line in a page is 4 bytes.
    // our squares are 8 pixels high.
    y = (y >> 2) * height;
    // are we in the first or second page
    var baseX = (byteIndex < 128) ? 0 : 4;
    // each bit is a square on the map, so 8 squares per byte
    baseX = (baseX + (byteIndex % 4)) * 8 * width;
    var j = Math.log2(bitMask);
    var x = baseX + (7 - j) * width;

    return [x, y];
}

function cleanupBuffer() {
    askedDataSize = 0;
    receivedDataSize = 0;
    receivedData = [];
}

function askNextData(newDataState, now) {
    // reset data vars
    cleanupBuffer();
    curDataState = newDataState;

    if(now) {
        askForData();
    } else {
        timeout = setTimeout(askForData, waitingTime);
    }
}

function sendAutoTrackerMessage(data, newState) {
    socket.send(JSON.stringify(data));

    // update state
    curState = newState;

    // update interface
    setAutoTrackerIcon("statusLoad");
}
</script>

<div class="fixed">
  <div class="menu">
    <table class="full menuTable">
      <tr>
        <td>{{=A("Home", _href=URL(f="home"), _class="menu")}}</td>
        <td>{{=A("Presets", _href=URL(f="presets"), _class="menu")}}</td>
        <td>{{=A("Randomizer", _href=URL(f="randomizer"), _class="menu")}}</td>
        <td>{{=A("Solver", _href=URL(f="solver"), _class="menu")}}</td>
        <td class="menu_selected">{{=A("Tracker", _href=URL(f="tracker"), _class="menu")}}</td>
        <td>{{=A("Plandomizer", _href=URL(f="plando"), _class="menu")}}</td>
        <td>{{=A("Plandository", _href=URL(f="plandorepo"), _class="menu")}}</td>
        <td>{{=A("Customizer", _href=URL(f="customizer"), _class="menu")}}</td>
        <td>{{=A("Statistics", _href=URL(f="extStats"), _class="menu")}}</td>
        <td>{{=A("Information & Contact", _href=URL(f="infos"), _class="menu")}}</td>
      </tr>
    </table>
  </div>
</div>

<div class="main">
{{include 'solver_web/t_main.html'}}

    <!-- item tracker buttons -->
    <div id="titleItem" class="titleItem">ITEM</div>
    <div id="startItem" class="startItem"><img src="/solver/static/images/play.svg" alt="Start" onclick="displayPopup(false)" data-toggle="tooltip" title="Start the Interactive Solver" data-placement="bottom" data-container="body" data-html="true"></div>
    <div id="repeatItem" class="repeatItem"><img src="/solver/static/images/repeat.svg" alt="Cancel Last" onclick="deleteLoc(false)" data-toggle="tooltip" title="Remove last visited location" data-placement="bottom" data-container="body" data-html="true" id="repeatItemImg"></div>
    <div id="binItem" class="binItem"><img src="/solver/static/images/bin.svg" alt="Clear" onclick="clearLocs(false)" data-toggle="tooltip" title="Remove all visited locations" data-placement="bottom" data-container="body" data-html="true"></div>

    <!-- tracker help -->
    <div id="help" class="help"><img src="/solver/static/images/help.svg" alt="Help" onclick="startTheTour(0)" data-toggle="tooltip" title="Display the help" data-placement="bottom" data-container="body" data-html="true"></div>

    <!-- auto tracker -->
    <div id="titleAutoTracker">AUTO TRACKER</div>
    <div id="startStopAutoTracker">
      <img id="startAutoTracker" src="/solver/static/images/play.svg" alt="Start AutoTracker" onclick="startAutoTracker()" data-toggle="tooltip" title="Start the Auto Tracker" data-placement="bottom" data-container="body" data-html="true">
      <img id="stopAutoTracker" src="/solver/static/images/shut_down.svg" alt="Stop AutoTracker" style="display: none" onclick="stopAutoTracker()" data-toggle="tooltip" title="Stop the Auto Tracker" data-placement="bottom" data-container="body" data-html="true">
    </div>
    <div id="helpAutoTracker"><img src="/solver/static/images/help.svg" alt="Help" onclick="startTheTour(1)" data-toggle="tooltip" title="Display the AutoTracker help" data-placement="bottom" data-container="body" data-html="true"></div>
    <div id="statusAutoTracker">
      <img id="statusKO" src="/solver/static/images/record_ko.svg" alt="statusKO" style="display: none" data-toggle="tooltip" title="AutoTracker status OK" data-placement="bottom" data-container="body" data-html="true">
      <img id="statusOK" src="/solver/static/images/record_ok.svg" alt="statusOK" style="display: none" data-toggle="tooltip" title="AutoTracker status KO" data-placement="bottom" data-container="body" data-html="true">
      <img id="statusLoad" src="/solver/static/images/record_load.svg" alt="statusLoad" style="display: none" data-toggle="tooltip" title="AutoTracker status Load" data-placement="bottom" data-container="body" data-html="true">
      <img id="statusNA" src="/solver/static/images/record.svg" alt="statusNA" data-toggle="tooltip" title="AutoTracker status NA" data-placement="bottom" data-container="body" data-html="true">
    </div>
    <textarea id="logAutoTracker" disabled></textarea>

    <!-- debug canvas pink color: de3994 -->
    <canvas id="debugMap" width="512" height="256"></canvas>
  </div>

  <!-- info on current loaded seed -->
  <p class="white">Current Seed:</p>
  <input type="text" name="cur_seed" id="cur_seed" value="n/a" readonly class="full">
  <p class="white">Current Preset:</p>
  <input type="text" name="cur_preset" id="cur_preset" value="n/a" readonly class="full">
</div>
