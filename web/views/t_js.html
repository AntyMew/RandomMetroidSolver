// https://stackoverflow.com/questions/16960690/chosen-harvesthq-resize-width-dynamically
$(document).ready(function(){      
   resizeChosen();
   jQuery(window).on('resize', resizeChosen);
});

function resizeChosen() {
   $(".chosen-container").each(function() {
       $(this).attr('style', 'width: 100%');
   });          
}

var loaded = false;

//-----------------------------------------------------------
// AREAS TRACKER

var firstClick = "";
var secondClick = "";

var lines = {};
var leaderLines = {};
var nextColor = 0;
var linesSeq = new Array();

var colors = ['grey', 'lime', 'pink',  'fuchsia', 'orange', 'yellow', 'purple', 'aqua', 'red', '#bfef45', 'white', 'cyan', 'magenta', 'olive', 'green', 'blue', 'maroon', 'teal'];

function resetLines() {
  for (var startPoint in lines) {
    if(lines[startPoint] != "") {
      var endPoint = lines[startPoint];
      lines[startPoint] = "";
      lines[endPoint] = "";
      leaderLines[startPoint].remove();
      leaderLines[startPoint] = "";
      leaderLines[endPoint] = "";
    }
  }
  lines = {};
  leaderLines = {};
  linesSeq = [];
  nextColor = 0;
}

function checkCompatibleAPs(startAP, endAP) {
{{
  response.write("  var vanillaAPs = {};\n".format(vanillaAPs), escape=False)
  response.write("  var vanillaBossesAPs = {};\n".format(vanillaBossesAPs), escape=False)
}}

  return (vanillaAPs.includes(startAP) && vanillaAPs.includes(endAP)) || (vanillaBossesAPs.includes(startAP) && vanillaBossesAPs.includes(endAP));
}

function isEscapeAP(ap) {
{{
    response.write("  var escapeAPs = {};\n".format(escapeAPs), escape=False)
}}

    return escapeAPs.includes(ap);
}

function clickPortal(elemId) {
    if(loaded == false || webServInProgress == true) {
        return;
    }

    // console.log("clickPortal "+elemId+" is escape ? "+isEscapeAP(elemId)+" escape mode ? "+escapeRando);

    isEscape = isEscapeAP(elemId);

    // prevent clicking on escape portals
    if(isEscape == true && (escapeRando == false || mode != "plando")) {
        return;
    }

    escapeStart = "tourianEscapeRoom4TopRight"
    escapeLine = escapeStart in lines;
    if(escapeLine == true) {
        escapeEnd = lines[escapeStart]
    }

    if(firstClick == ""){
        if(isEscape == true && escapeLine == true && elemId != escapeStart && elemId != escapeEnd){
            // escape line already there, allow only to select a portal of the escape line
            return;
        }

        // highlight first element, allow highlight of already linked portals for link removal
        firstClick = elemId;
        $("#"+firstClick).addClass("addBorder");
    } else if(firstClick == elemId){
        // click back on same portal
        $("#"+firstClick).removeClass("addBorder");
        firstClick = "";
    } else if(secondClick == "" && elemId != firstClick) {
        isFirstEscape = isEscapeAP(firstClick);

        if(isFirstEscape != isEscape) {
            // no mixing escape ap with other aps
            return;
        }

        if(firstClick in lines) {
            // first portal was an already connected one, replace the selection
            $("#"+firstClick).removeClass("addBorder");
            firstClick = elemId;
            $("#"+firstClick).addClass("addBorder");
        } else {
            if(! ((firstClick in lines) || (elemId in lines))) {
                // add new line

                if(isEscape == true) {
                    // escape aps, one must be tourian exit
                    if(firstClick != escapeStart && elemId != escapeStart) {
                        alert("For escape one node must be Tourian escape.");
                        return;
                    }
                } else if(checkCompatibleAPs(firstClick, elemId) == false) {
                    alert("Warning:\n\tYou are mixing an Areas access point and a Bosses access point.\n\tIt's an invalid transition except for Plando seeds.");
                }

                if(init == true) {
                    secondClick = elemId;
                    ajaxCall({action: "add", scope: "area", startPoint: firstClick, endPoint: secondClick}, "upload");
                    firstClick = "";
                    secondClick = "";
                } else {
                    // warn the user that he have to click on '>' first
                    alert("Please initialize the tracker/plando first by clicking on the Play button.");
                }
            }
        }
    }
}

function addLine(startPoint, endPoint) {
  var startPointElem = document.getElementById(startPoint);
  var endPointElem = document.getElementById(endPoint);

  var line = new LeaderLine(startPointElem, endPointElem,
                            {startPlug: 'disc',
                             endPlug: 'disc',
                             dropShadow: true,
                             startPlugColor: colors[nextColor],
                             endPlugColor: colors[nextColor],
                             size: 4,
                             gradient: true,
                             outlineColor: 'rgb(255, 255, 255)',
                             outline: true,
                             outlineSize: 0.10});

  nextColor += 1;
  $("#"+startPoint).removeClass("addBorder");

  lines[startPoint] = endPoint;
  lines[endPoint] = startPoint;

  leaderLines[startPoint] = line;
  leaderLines[endPoint] = line;

  linesSeq.push(startPoint);
}

function clearLines() {
  if(loaded == false || webServInProgress == true || init == false) {
    return;
  }

  if(! isActive("binArea")) {
    return;
  }

  var result = confirm("Reset seed transitions ?");
  if(result == false){
    return;
  }

  ajaxCall({action: "clear", scope: "area"}, "upload");
}

function deleteLine() {
  if(loaded == false || webServInProgress == true || init == false) {
    return;
  }

  if(! isActive("repeatArea")) {
    return;
  }

  // check if a portal linked to an existing line is selected
  if(firstClick != "" && firstClick in lines) {
    $("#"+firstClick).removeClass("addBorder");
    ajaxCall({action: "remove", scope: "area", startPoint: firstClick}, "upload");
    firstClick = "";
  } else {
    ajaxCall({action: "remove", scope: "area"}, "upload");
  }
}

function startAnimation(elem) {
  if(elem.id in leaderLines) {
    var line = leaderLines[elem.id];
    line.dash = {animation: true};
  }
}

function stopAnimation(elem) {
  if(elem.id in leaderLines) {
    var line = leaderLines[elem.id];
    line.dash = false;
  }
}



//-----------------------------------------------------------
// COMMON

var ajaxChainedActions = [];

function ajaxFailJSON(jqXHR, textStatus) {
  webServInProgress = false;

  // if chained actions were planned, cancel them
  ajaxChainedActions = [];

  console.log("error ["+jqXHR.responseJSON+"] ["+jqXHR.responseText+"] ["+textStatus+"]");

  setWSIcon("warning");
  document.getElementById("flash").innerHTML = jqXHR.responseText;
  $('#flash').show();
  $('#overlay').hide();
  $('#loadingGIF').hide();
}

function ajaxCall(dataDict, msg, okFunc=ajaxOkGet) {
    if(!("mode" in dataDict)) {
      dataDict["mode"] = document.getElementById("mode").value;
    }

    if(typeof debug !== 'undefined' && debug == true) {
      dataDict["debug"] = true;
    }

    // always store the timer
    if(escapeRando == true && mode == "plando") {
      var value = document.getElementById("timer").value;
      dataDict["escapeTimer"] = value;
    }

    webServInProgress = true;

    var request = $.ajax({
      url: "{{=URL(f='trackerWebService')}}",
      method: "POST",
      data: dataDict,
      dataType: "json",
      crossDomain: true
    });

    setWSIcon(msg);

    request.done(okFunc);
    request.fail(ajaxFailJSON);
}

function ajaxCallChained() {
  // to call several ws, one after the other

  console.log("ajaxCallChained with " + ajaxChainedActions.length + " actions");

  var nextAction = ajaxChainedActions.pop();
  if("idxFunc" in nextAction) {
    var funcName = nextAction["idxFunc"];
    window[funcName](true);
  }
  ajaxCall(nextAction, "upload", ajaxOkChained);
}

function ajaxOkChained(jsonData) {
  // hard coded for now, as it's the only one we use in the tracker
  ajaxOkGet(jsonData, "success", null, true);

  if(ajaxChainedActions.length > 0) {
    console.log("ajaxOkChained: " + ajaxChainedActions.length + " actions remaining");
    var nextAction = ajaxChainedActions.pop();
    if("idxFunc" in nextAction) {
      var funcName = nextAction["idxFunc"];
      window[funcName](true);
    }
    ajaxCall(nextAction, "upload", ajaxOkChained);
  } else {
    console.log("ajaxOkChained: no actions remaining");
    webServInProgress = false;
  }
}

function setWSIcon(icon) {
  var names = ["checkmark", "warning", "download", "upload", "refresh"];
  for(var i=0; i<names.length; i++) {
    if(names[i] == icon){
      document.getElementById(names[i]).style.display = "block";
    } else {
      document.getElementById(names[i]).style.display = "none";
    }
  }
}

function ajaxOkGet(jsonData, status, dummy, chained=false) {
  if(chained == false) {
    webServInProgress = false;
  }

  $('#overlay').hide();
  $('#loadingGIF').hide();

  // get dicts availableLocations and visitedLocations
  console.log("json received: [ "+jsonData+" ]");
  if(jsonData == "OK") {
    setWSIcon("checkmark");
    return;
  }

  if(jsonData["errorMsg"] != "") {
    document.getElementById("flash").innerHTML = jsonData["errorMsg"];
    $('#flash').show();
  }

  mode = jsonData["mode"];
  area = jsonData["areaRando"];
  boss = jsonData["bossRando"];
  escapeRando = jsonData["escapeRando"];
  seed = jsonData["seed"];
  preset = jsonData["preset"];
  init = true;

  document.getElementById("mode").value = mode;
  document.getElementById("cur_seed").value = seed;
  document.getElementById("cur_preset").value = preset;

  if(mode != "standard") {
    hideItemPopup();
  }

  setActive(mode, area, boss);

  resetItems();
  resetLines();

  if("availableLocations" in jsonData) {
    for(var locName in jsonData["availableLocations"]) {
      // console.log(locName+" is available");
      var locData = jsonData["availableLocations"][locName];
      locsInfo[locName]["state"] = "available";
      locsInfo[locName]["difficulty"] = locData["difficulty"];
      locsInfo[locName]["canHidden"] = locData["canHidden"];
      locsInfo[locName]["visibility"] = locData["visibility"];
      locsInfo[locName]["accessPoint"] = locData["accessPoint"];
      locsInfo[locName]["path"] = locData["path"];

      $("#"+locName).attr("class", "baseLoc marker_available_"+locData["difficulty"]);
      var tooltip = getTooltip(locName, locData, "?", false);
      $("#"+locName+'[data-toggle="tooltip"]').attr("title", tooltip).tooltip('fixTitle');

      // check if a boss was at that location
      if("boss" in locsInfo[locName]) {
        var bossName = locsInfo[locName]["boss"];
        if(bossName != "MotherBrain") {
          document.getElementById(bossName+"G4").style.display = "none";
        }
      }
    }
  }

  if("visitedLocations" in jsonData) {
    for(var locName in jsonData["visitedLocations"]) {
      // console.log(locName+" is visited");
      var locData = jsonData["visitedLocations"][locName];
      locsInfo[locName]["state"] = "visited";
      locsInfo[locName]["difficulty"] = locData["difficulty"];
      locsInfo[locName]["canHidden"] = locData["canHidden"];
      locsInfo[locName]["visibility"] = locData["visibility"];
      locsInfo[locName]["item"] = locData["item"];
      locsInfo[locName]["accessPoint"] = locData["accessPoint"];

      // keep current loc zoomed
      var base = "baseLoc";
      if($("#"+locName).hasClass("baseLocOver")) {
        base = "baseLocOver";
      }

      var className = "marker_visited_"+locData["difficulty"]+"_"+locData["item"];
      $("#"+locName).attr("class", base+" "+className);
      var tooltip = getTooltip(locName, locData, locData["item"], true);
      $("#"+locName+'[data-toggle="tooltip"]').attr("title", tooltip).tooltip('fixTitle');

      // check if a boss was at that location
      if("boss" in locsInfo[locName]) {
        var bossName = locsInfo[locName]["boss"];
        if(bossName != "MotherBrain") {
          document.getElementById(bossName+"G4").style.display = "block";
        }
      }

      // add item
      addItem(locData["item"]);
    }

    if(mode == "plando") {
      var elem = "repeatPlandoImg";
    } else {
      var elem = "repeatItemImg";
    }
    var tooltip = "Remove last placed item";
    if(Object.keys(jsonData["visitedLocations"]).length > 0) {
      var tooltip = tooltip + ": "+jsonData["last"]["item"]+" at "+jsonData["last"]["loc"];
    }
    $("#"+elem+'[data-toggle="tooltip"]').attr("title", tooltip).tooltip('fixTitle');
  }

    if(mode == "seedless") {
        // load items as all locs contain Nothing
        var collectedItems = jsonData["collectedItems"];
        for(var i=0; i<collectedItems.length; i++) {
            var item = collectedItems[i];
            if(item != "Nothing") {
                addItem(item);
            }
        }
    }

  setItemCount("Missile");
  setItemCount("Super");
  setItemCount("PowerBomb");
  setReserveCount();

  // set remaining locations as sequence breakable
  if("remainLocations" in jsonData) {
    for(var locName in jsonData["remainLocations"]) {
      // console.log(locName+": sequence breakable");
      var locData = jsonData["remainLocations"][locName];
      locsInfo[locName]["state"] = "break";
      locsInfo[locName]["difficulty"] = locData["difficulty"];
      locsInfo[locName]["canHidden"] = locData["canHidden"];
      locsInfo[locName]["visibility"] = locData["visibility"];

      // keep current loc zoomed
      var base = "baseLoc";
      if($("#"+locName).hasClass("baseLocOver")) {
        base = "baseLocOver";
      }

      var className = "marker_available_break";
      $("#"+locName).attr("class", base+" "+className);
      var tooltip = getTooltip(locName, locData, "?", false);
      $("#"+locName+'[data-toggle="tooltip"]').attr("title", tooltip).tooltip('fixTitle');

      // check if a boss was at that location
      if("boss" in locsInfo[locName]) {
        var bossName = locsInfo[locName]["boss"];
        if(bossName != "MotherBrain") {
          document.getElementById(bossName+"G4").style.display = "none";
        }
      }
    }
  }

  if("lastAP" in jsonData) {
    lastAP = jsonData["lastAP"];
  }
  $("#lastAP").attr("class", "lastAP "+lastAP+"Gps");
  $("#gps"+'[data-toggle="tooltip"]').attr("title", lastAP).tooltip('fixTitle');

  setWSIcon("checkmark");

  // add area transitions
  var arrayLength = jsonData["linesSeq"].length;
  for(var i=0; i<arrayLength; i++) {
    addLine(jsonData["linesSeq"][i][0], jsonData["linesSeq"][i][1]);
  }

  // add timer input
  if(escapeRando == true && mode == "plando") {
    var timer = document.getElementById("timer");
    timer.value = jsonData["escapeTimer"];
    timer.style.display = "block";
  } else {
    document.getElementById("timer").style.display = "none";
  }

  // if no available locations, display a popup telling you're stuck
  if(Object.keys(jsonData["availableLocations"]).length == 0 && chained == false) {
    if(jsonData["allTransitions"] == true && (( ! "state" in locsInfo["MotherBrain"] ) || locsInfo["MotherBrain"]["state"] != "visited")) {
      alert("You're stuck, you can't finish this seed with the given preset.");
    }
  }
}

function setActive(mode, area, boss) {
    var itemElems = ["repeatItem", "binItem"];
    var plandoElems = ["repeatPlando", "binPlando", "savePlando"];
    var areaElems = ["repeatArea", "binArea"];
    if(mode != "plando") {
        for(var i=0; i<itemElems.length; i++) {
            $("#"+itemElems[i]).removeClass("greyed");
        }
        for(var i=0; i<plandoElems.length; i++) {
            $("#"+plandoElems[i]).addClass("greyed");
        }
    } else {
        for(var i=0; i<itemElems.length; i++) {
            $("#"+itemElems[i]).addClass("greyed");
        }
        for(var i=0; i<plandoElems.length; i++) {
            $("#"+plandoElems[i]).removeClass("greyed");
        }
    }
    if(area == true || boss == true) {
        for(var i=0; i<areaElems.length; i++) {
            $("#"+areaElems[i]).removeClass("greyed");
        }
    } else {
        for(var i=0; i<areaElems.length; i++) {
            $("#"+areaElems[i]).addClass("greyed");
        }
    }
    if(mode == "seedless") {
        document.getElementById("pause_background").style.display = "none";
        document.getElementById("pause_background_seedless").style.display = "block";
    } else {
        document.getElementById("pause_background").style.display = "block";
        document.getElementById("pause_background_seedless").style.display = "none";
    }
}

function isActive(elemId) {
  if(elemId.includes("Plando")) {
    if(mode == "plando") {
      return true;
    } else {
      return elemId == "startPlando";
    }
  }
  if(elemId.includes("Item")) {
    if(mode != "plando") {
      return true;
    } else {
      return elemId == "startItem";
    }
  }
  if(elemId.includes("Area")) {
    return area || boss;
  }
}

//-----------------------------------------------------------
// ITEMS TRACKER

var lastAP = "landingSite";
var mode = "standard";
var area = true;
var boss = true;
var escapeRando = true;
var init = false;
var webServInProgress = false;
var race = false;

// can add more variables:
//  -state: posible values: ["available", "visited", "break"]
//  -difficulty: possible values: ["easy", "medium", "hard", "harder", "hardcore", "mania"]
var locsInfo = {
  EnergyTankGauntlet: {left: 29.4, top: 5.4},
  Bomb: {left: 37, top: 11.35},
  EnergyTankTerminator: {left: 24.8, top: 11.35},
  ReserveTankBrinstar: {left: 9.4, top: 56.3},
  ChargeBeam: {left: 13.3, top: 67.05},
  MorphingBall: {left: 34.3, top: 49.45},
  EnergyTankBrinstarCeiling: {left: 39.9, top: 49.45},
  EnergyTankEtecoons: {left: 2.9, top: 65.6},
  EnergyTankWaterway: {left: 4.7, top: 70.09},
  EnergyTankBrinstarGate: {left: 17.2, top: 62.5},
  XRayScope: {left: 42.7, top: 55.27},
  Spazer: {left: 57, top: 58.3},
  EnergyTankKraid: {left: 50.97, top: 66.8},
  VariaSuit: {left: 67.6, top: 66.75},
  IceBeam: {left: 38.6, top: 73.99},
  EnergyTankCrocomire: {left: 25.8, top: 82.5},
  HiJumpBoots: {left: 40.4, top: 80},
  GrappleBeam: {left: 10.6, top: 91.65},
  ReserveTankNorfair: {left: 51.02, top: 73.99},
  SpeedBooster: {left: 69.05, top: 73.95},
  WaveBeam: {left: 61.4, top: 76.9},
  EnergyTankRidley: {left: 75.6, top: 94.6},
  ScrewAttack: {left: 76.45, top: 90.4},
  EnergyTankFirefleas: {left: 92.5, top: 82.8},
  ReserveTankWreckedShip: {left: 71.71, top: 5.7},
  EnergyTankWreckedShip: {left: 74.7, top: 7.3},
  RightSuperWreckedShip: {left: 77.4, top: 13.3},
  GravitySuit: {left: 66.97, top: 7.2},
  EnergyTankMamaturtle: {left: 74.93, top: 52.3},
  PlasmaBeam: {left: 84.2, top: 36.87},
  ReserveTankMaridia: {left: 77.55, top: 56.85},
  SpringBall: {left: 89.1, top: 58.4},
  EnergyTankBotwoon: {left: 85.3, top: 46.2},
  SpaceJump: {left: 91.1, top: 50.9},
  PowerBombCrateriasurface: {left: 44.5, top: 3.9},
  MissileoutsideWreckedShipbottom: {left: 61.35, top: 10.1},
  MissileoutsideWreckedShiptop: {left: 62.1, top: 2.75},
  MissileoutsideWreckedShipmiddle: {left: 61.35, top: 5.55},
  MissileCrateriamoat: {left: 47.5, top: 8.4},
  MissileCrateriabottom: {left: 32.25, top: 29.6},
  MissileCrateriagauntletright: {left: 24.2, top: 6.9},
  MissileCrateriagauntletleft: {left: 23.2, top: 6.9},
  SuperMissileCrateria: {left: 36.1, top: 15.98},
  MissileCrateriamiddle: {left: 28.4, top: 12.85},
  PowerBombgreenBrinstarbottom: {left: 8.5, top: 61},
  SuperMissilepinkBrinstar: {left: 19.94, top: 64},
  MissilegreenBrinstarbelowsupermissile: {left: 7.5, top: 56.3},
  SuperMissilegreenBrinstartop: {left: 6.6, top: 54.9},
  MissilegreenBrinstarbehindmissile: {left: 10.55, top: 55.6},
  MissilegreenBrinstarbehindreservetank: {left: 10.37, top: 57},
  MissilepinkBrinstartop: {left: 13.3, top: 61},
  MissilepinkBrinstarbottom: {left: 13.3, top: 65.5},
  PowerBombpinkBrinstar: {left: 11.4, top: 62.5},
  MissilegreenBrinstarpipe: {left: 18, top: 67.2},
  PowerBombblueBrinstar: {left: 32.25, top: 49.45},
  MissileblueBrinstarmiddle: {left: 40.8, top: 49.45},
  SuperMissilegreenBrinstarbottom: {left: 1.9, top: 65.6},
  MissileblueBrinstarbottom: {left: 37, top: 50.99},
  MissileblueBrinstartop: {left: 38, top: 45.6},
  MissileblueBrinstarbehindmissile: {left: 38, top: 47},
  PowerBombredBrinstarsidehopperroom: {left: 54.15, top: 44.6},
  PowerBombredBrinstarspikeroom: {left: 54.15, top: 49.2},
  MissileredBrinstarspikeroom: {left: 53.2, top: 49.2},
  MissileKraid: {left: 54.9, top: 65.2},
  Missilelavaroom: {left: 48, top: 76.95},
  MissilebelowIceBeam: {left: 35.7, top: 76.95},
  MissileaboveCrocomire: {left: 45.2, top: 80.1},
  MissileHiJumpBoots: {left: 41.4, top: 78.6},
  EnergyTankHiJumpBoots: {left: 42.4, top: 78.5},
  PowerBombCrocomire: {left: 16.3, top: 82.5},
  MissilebelowCrocomire: {left: 21, top: 90.15},
  MissileGrappleBeam: {left: 15.3, top: 90.25},
  MissileNorfairReserveTank: {left: 51.9, top: 73.95},
  MissilebubbleNorfairgreendoor: {left: 53.8, top: 73.95},
  MissilebubbleNorfair: {left: 55.7, top: 78.45},
  MissileSpeedBooster: {left: 68.1, top: 73.95},
  MissileWaveBeam: {left: 58.55, top: 77.1},
  MissileGoldTorizo: {left: 74.5, top: 88.9},
  SuperMissileGoldTorizo: {left: 75.5, top: 88.9},
  MissileMickeyMouseroom: {left: 84.1, top: 81.4},
  MissilelowerNorfairabovefireflearoom: {left: 90.75, top: 73.7},
  PowerBomblowerNorfairabovefireflearoom: {left: 92.6, top: 75.2},
  PowerBombPowerBombsofshame: {left: 87.9, top: 87.35},
  MissilelowerNorfairnearWaveBeam: {left: 85, top: 73.7},
  MissileWreckedShipmiddle: {left: 68.9, top: 11.75},
  MissileGravitySuit: {left: 69.8, top: 7.2},
  MissileWreckedShiptop: {left: 77.4, top: 2.65},
  SuperMissileWreckedShipleft: {left: 71.8, top: 13.3},
  MissilegreenMaridiashinespark: {left: 67.3, top: 52.2},
  SuperMissilegreenMaridia: {left: 68.1, top: 50.75},
  MissilegreenMaridiatatori: {left: 75.7, top: 53.7},
  SuperMissileyellowMaridia: {left: 69.6, top: 43.1},
  MissileyellowMaridiasupermissile: {left: 68.6, top: 43.1},
  MissileyellowMaridiafalsewall: {left: 76.7, top: 43},
  MissileleftMaridiasandpitroom: {left: 76.7, top: 55.4},
  MissilerightMaridiasandpitroom: {left: 79.6, top: 55.4},
  PowerBombrightMaridiasandpitroom: {left: 80.5, top: 56.8},
  MissilepinkMaridia: {left: 80.5, top: 47.85},
  SuperMissilepinkMaridia: {left: 81.5, top: 47.85},
  MissileDraygon: {left: 97.65, top: 44.7},
  Kraid: {left: 66.16, top: 66, boss: "Kraid"},
  Ridley: {left: 76.6, top: 93.8, boss: "Ridley"},
  Phantoon: {left: 78.8, top: 16.3, boss: "Phantoon"},
  Draygon: {left: 92.6, top: 50, boss: "Draygon"},
  MotherBrain: {left: 22, top: 33.2, boss: "MotherBrain"}
};

window.onload = function(){
  initCurMode();

  ajaxCall({action: "get", scope: "common"}, "download");
  $("#lastAP").attr("class", "lastAP "+lastAP+"Gps");

  // display the help on first connection to the tracker
{{
  if "firstTime" in curSession and curSession["firstTime"] == True:
    curSession["firstTime"] = False
}}
    startTheTour(0);
{{
    pass
}}

  var filesInput = document.getElementById("uploadFile");
  filesInput.addEventListener("change", function(event) {
    var files = event.target.files; // It returns a FileList object
    var file = files[0];
  
    var reader = new FileReader();
  
    reader.onload = function(e) {
          // check sfc or smc extention
        var re = /(?:\.([^.]+))?$/;
          var ext = re.exec(file.name)[1];
        if( ! (ext === "sfc" || ext === "smc" || ext === "SFC" || ext === "SMC") ) {
            document.getElementById("uploadFile").value = "";
            alert("wrong extension: "+ext);
            return false;
        }

        var re = /((.*)\.[^.]+)?$/;
        var base = re.exec(file.name)[1];
  
        var outFileName = file.name.replace(/\.[^/.]+$/, ".json");
        document.getElementById("fileName").value = file.name;

        var fileSize = file.size;
        if( fileSize > 4*1024*1024 ) {
            document.getElementById("uploadFile").value = "";
            alert("Wrong ROM file size: "+fileSize.toString());
            return false;
        } else if( fileSize == 3146240) {
            document.getElementById("uploadFile").value = "";
            alert("headered ROM detected, please use an unheadered ROM");
            return false;
        } else if(mode == "plando" && fileSize == 4*1024*1024) {
            alert("Warning: You won't be able to upload a Sprite customized seed in the Plandository (hosting space constraints)");
        }

        var bytes = new Uint8Array(e.target.result);

        // detect race mode patch
        race = false;
        for(var addr=0x1C0200; addr<0x1C0210; addr++) {
            if(bytes[addr] != 0xff) {
                if(document.getElementById("mode").value == "plando") {
                    clearInputSeed();
                    alert("race protected seed detected");
                    return false;
                } else {
                    race = true;
                    break;
                }
            }
        }

        var romData = {};
  
        // locations items
        var addresses = new Array({{=", ".join(str(address) for address in addresses["locations"])}});
  
        var arrayLength = addresses.length;
        for(var i=0; i<arrayLength; i++) {
            romData[addresses[i]] = bytes[addresses[i]];
            romData[addresses[i]+1] = bytes[addresses[i]+1];
            romData[addresses[i]+4] = bytes[addresses[i]+4];
        }
  
        // patches
        var addresses = new Array({{=", ".join(str(address) for address in addresses["patches"])}});
        var arrayLength = addresses.length;
        for(var i=0; i<arrayLength; i++) {
            romData[addresses[i]] = bytes[addresses[i]];
        }

        // transitions
        var addresses = new Array({{=", ".join(str(address) for address in addresses["transitions"])}});
        var arrayLengthTransitions = addresses.length;
        for(var i=0; i<arrayLengthTransitions; i++) {
            // room ptr
            romData[addresses[i]] = bytes[addresses[i]];
            romData[addresses[i]+1] = bytes[addresses[i]+1];
            // direction
            romData[addresses[i]+3] = bytes[addresses[i]+3];
            // screen x y
            romData[addresses[i]+6] = bytes[addresses[i]+6];
            romData[addresses[i]+7] = bytes[addresses[i]+7];
            // distance to spawn
            romData[addresses[i]+8] = bytes[addresses[i]+8];
            romData[addresses[i]+9] = bytes[addresses[i]+9];
            // asmPtr
            romData[addresses[i]+10] = bytes[addresses[i]+10];
            romData[addresses[i]+11] = bytes[addresses[i]+11];
        }
  
        // misc
        var addresses = new Array({{=", ".join(str(address) for address in addresses["misc"])}});
        var arrayLength = addresses.length;
        for(var i=0; i<arrayLength; i++) {
            romData[addresses[i]] = bytes[addresses[i]];
        }

        // ranges
        var ranges = new Array({{=", ".join(str(range) for range in addresses["ranges"])}});
        var arrayLength = ranges.length;
        for(var i=0; i<arrayLength; i+=2) {
          low = ranges[i];
          high = ranges[i+1];
          for(var j=low; j<=high; j++) {
            romData[j] = bytes[j];
          }
        }

        romData["romFileName"] = outFileName;
  
        var json = JSON.stringify(romData);
  
        var output = document.getElementById("romJson");
        output.value = json;

        setGuessedPreset(file.name);

        document.getElementById("startLocationVisibility").style.display = "none";
    }
  
    reader.readAsArrayBuffer(file);
  }, false);

  // defined in plando.html/tracker.html
  onloadHook();

  dragElement(document.getElementById("solverPopup"), "solverGrab");

  $("#placeItemButton").keypress(onEnterKey);

  addTooltipCallback();

  loaded = true;
}

function addTooltipCallback() {
    // display the next ap while the tooltip is displayed
    $("[data-toggle=tooltip]").on('show.bs.tooltip', function (callbackData) {
        var locName = callbackData.target.id;
        if(locName in locsInfo) {
            var locData = locsInfo[locName];

            // display next ap
            if("accessPoint" in locData) {
                // display path
                if(nextAP != lastAP && "path" in locData) {
                    var path = locData["path"];
                    for(var i=0; i<path.length; i++) {
                        var gps = "gps_"+(i+1);
                        var ap = path[i];

                        $("#"+gps).attr("class", "nextAP "+ap+"Gps");
                        document.getElementById(gps).style.display = "block";
                    }
                    document.getElementById("lastAP").style.display = "none";
                    document.getElementById("nextAP").style.display = "none";
                } else {
                    var nextAP = locData["accessPoint"];
                    $("#nextAP").attr("class", "nextAP "+nextAP+"Gps");
                    document.getElementById("nextAP").style.display = "block";
                    $("#nextgps"+'[data-toggle="tooltip"]').attr("title", nextAP).tooltip('fixTitle');
                }
            }
        }
    });
    $("[data-toggle=tooltip]").on('hide.bs.tooltip', function (a) {
        document.getElementById("lastAP").style.display = "block";

        // hide next ap
        document.getElementById("nextAP").style.display = "none";

        // hide path aps
        for(var i=1; i<=16; i++) {
            document.getElementById("gps_"+i).style.display = "none";
        }
    });
}

function onEnterKey(event) {
  if(event.keyCode === 13) {
    if(document.getElementById("itemPopup").style.display != "none") {
      placeItem();
    }
  }
}

function setGuessedPreset(romName){
  var preset = guessVARIAPreset(romName);
  if(preset != null) {
    document.getElementById("preset").value = preset;
    $("#preset").trigger("chosen:updated");
  }
}

function guessVARIAPreset(filename) {
  var re = /VARIA_Randomizer_[A]?[B]?[F]?[M]?[Z]?X\d+_(\w+)/;
  var match = filename.match(re);
  if(match == null) {
    re = /VARIA_Plandomizer_[A]?[B]?FX\d+_(\w+)/;
    match = filename.match(re);
  }
  if(match != null) {
    var data = match[1];
    console.log(data);

    var re = /^(.*)_([a-zA-Z0-9]+)$/;
    var match = data.match(re);

    console.log(match);

    if(match != null){
      var pS = match[2];
      if(pS == "slowest" || pS == "slow" || pS == "medium" || pS == "fast" || pS == "fastest" || pS == "basic" || pS == "VARIAble" || pS == "speedrun") {
        return match[1];
      } else {
        return match[1] + '_' + match[2];
      }
    } else {
      return data;
    }
  } else {
    return null;
  }
}

function mouseOver(elem) {
  var locName = elem.id;

  if("state" in locsInfo[locName]) {
    $(elem).removeClass("baseLoc");
    $(elem).addClass("baseLocOver");

    if(locsInfo[locName]["state"] == "available"){
      var className = "marker_"+locsInfo[locName]["state"]+"_"+locsInfo[locName]["difficulty"];
      var classNameOver = "marker_over_"+locsInfo[locName]["difficulty"];
      $(elem).removeClass(className);
      $(elem).addClass(classNameOver);
    }

    var newTop = locsInfo[locName].top - 0.75;
    var newLeft = locsInfo[locName].left - 0.5;
    $(elem).css({"top": newTop+"%", "left": newLeft+"%"});
  }
}

function mouseOut(elem) {
  var locName = elem.id;

  if("state" in locsInfo[locName]) {
    $(elem).removeClass("baseLocOver");
    $(elem).addClass("baseLoc");

    if(locsInfo[locName]["state"] == "available"){
      var className = "marker_"+locsInfo[locName]["state"]+"_"+locsInfo[locName]["difficulty"];
      var classNameOver = "marker_over_"+locsInfo[locName]["difficulty"];
      $(elem).removeClass(classNameOver);
      $(elem).addClass(className);
    }

    var newTop = locsInfo[elem.id].top;
    var newLeft = locsInfo[elem.id].left;
    $(elem).css({"top": newTop+"%", "left": newLeft+"%"});
  }
}

function displayPopup(isPlando) {
  if(loaded == false || webServInProgress == true) {
    return;
  }

  if(isPlando == true) {
    document.getElementById("solverPopupText").innerHTML = "Select an already randomized ROM as base to start your Plando<br/>or a Plando ROM to continue working on it";
  } else {
    document.getElementById("solverPopupText").innerHTML = "Select your randomized ROM to solve<br/>or none for seed less mode";
    document.getElementById("fillPlandoVisibility").style.display = "none";
  }

  // display popup
  document.getElementById("solverPopup").style.display = "block";
  // chosen must be activated when it's visible, else it doesn't work...
  $(".chzn-select").chosen();
  resizeChosen();
}

function hidePopup() {
  document.getElementById("solverPopup").style.display = "none";
}

function initSolver() {
  if(loaded == false || webServInProgress == true) {
    return;
  }

  console.log("initSolver");

  var mode = "seedless";
  var romJson = document.getElementById("romJson");
  var romJsonValue = romJson.value;

  if(globalPlando == true) {
    mode = "plando";
    if(romJsonValue.length == 0){
      return;
    }
  } else {
    if(romJsonValue.length == 0) {
      mode = "seedless";
    } else {
      mode = "standard";
    }
  }

  // reset everything
  resetLocsInfo();

  // prepare parameters for WS
  ajaxCall({action: "init",
            scope: "common",
            romJson: romJsonValue,
            preset: document.getElementById("preset").value,
            fileName: document.getElementById("fileName").value,
            fill: document.getElementById("fillPlando").checked,
            startLocation: document.getElementById("startLocation").value,
            mode: mode, race: race}, "download");

  hidePopup();
  $('#hideRandoOverlay').hide();
}

function handleHide(locName) {
  // console.log("handleHide locName: "+locName+" canHidden: "+locsInfo[locName]["canHidden"]);

  if("canHidden" in locsInfo[locName] && locsInfo[locName]["canHidden"] == true) {
    document.getElementById("hideItemVisibility").style.display = "block";
    document.getElementById("hideItem").checked = locsInfo[locName]["visibility"] == "Hidden";
  } else {
    document.getElementById("hideItemVisibility").style.display = "none";
    document.getElementById("hideItem").checked = false;
  }
}

function clickLoc(elem) {
  if(loaded == false || webServInProgress == true || init == false) {
    return;
  }

  var locName = elem.id;

  if(mode == "plando") {
    // we put an item in boss locations which is the boss' name
    if("boss" in locsInfo[locName]) {
      // check that lock is in the available list
      if("state" in locsInfo[locName] && (locsInfo[locName]["state"] == "available" || locsInfo[locName]["state"] == "break")) {
        ajaxCall({action: "add", scope: "item", locName: locName, itemName: locsInfo[locName]["boss"]}, "upload");

        if(locName == "MotherBrain") {
          alert("SEE YOU NEXT MISSION");
        }
      }
      return;
    }

    if("state" in locsInfo[locName] && locsInfo[locName]["state"] == "visited") {
      document.getElementById("itemPopupText").innerHTML = "Replace item at "+locName+":";
      $("#item").val(locsInfo[locName]["item"]);
    } else if(mode == "plando") {
      document.getElementById("itemPopupText").innerHTML = "Item to place at "+locName+":";
    } else {
      document.getElementById("itemPopupText").innerHTML = "Item picked up at "+locName+":";
    }
    document.getElementById("locName").value = locName;

    if(mode == "plando") {
      handleHide(locName);
    }

    // display item selector
    document.getElementById("itemPopup").style.display = "block";
    $("#item").imagepicker();
    document.getElementById("placeItemButton").focus();
  } else {
    // check that lock is in the available list
    if("state" in locsInfo[locName] && (locsInfo[locName]["state"] == "available" || locsInfo[locName]["state"] == "break")) {
      // call webservice
      console.log("add item loc: "+locName);
      ajaxCall({action: "add", scope: "item", locName: locName}, "upload");
  
      // if mother brain loc, display end message
     if(locName == "MotherBrain") {
       alert("SEE YOU NEXT MISSION");
     }
    } else {
        // uncollect it
        console.log("remove item loc: "+locName);
        ajaxCall({action: "remove", scope: "item", locName: locName}, "upload");
    }
  }
}

function actionItem(itemName, action) {
    if(loaded == false || webServInProgress == true || init == false) {
        return;
    }

    if(mode == "seedless") {
        console.log("actionItem itemName: "+itemName+" action: "+action);

        // call webservice
        ajaxCall({action: action, scope: "item", itemName: itemName}, "upload");
    }
}

function placeItem() {
  if(loaded == false || webServInProgress == true || init == false) {
    return;
  }

  var item = document.getElementById("item").value;
  var locName = document.getElementById("locName").value;
  var hide = document.getElementById("hideItem").checked;

  // check that lock is in the available list
  if("state" in locsInfo[locName] && (locsInfo[locName]["state"] == "available" || locsInfo[locName]["state"] == "break")) {
    ajaxCall({action: "add", scope: "item", locName: locName, itemName: item, hide: hide}, "upload");
  } else {
    ajaxCall({action: "replace", scope: "item", locName: locName, itemName: item, hide: hide}, "upload");
  }
}

function hideItemPopup() {
  document.getElementById("itemPopup").style.display = "none";
}

function deleteLoc(isPlando) {
  if(loaded == false || webServInProgress == true || init == false) {
    return;
  }
  if(isPlando == true && ! isActive("repeatPlando")) {
    return;
  }
  if(isPlando == false && ! isActive("repeatItem")) {
    return;
  }

  // reset everything
  resetLocsInfo();

  ajaxCall({action: "remove", scope: "item"}, "upload");
}

function resetLocsInfo() {
  // remove info and reset css
  var keys = ["state", "difficulty"];
  for(var locName in locsInfo) {
    for(var i in keys) {
      var key = keys[i];
      // console.log("is "+keys[key]+" in locsInfo["+locName+"] ?");
      if(key in locsInfo[locName]) {
        // console.log("delete locsInfo["+locName+"]["+key+"]");
        delete locsInfo[locName][key];
      }
    }
    $("#"+locName).attr("class", "baseLoc");
    $("#"+locName+'[data-toggle="tooltip"]').attr("title", "").tooltip('fixTitle');
    $("#"+locName+'[data-toggle="tooltip"]').attr("data-original-title", "").tooltip('fixTitle');
  }
  lastAP = "landingSite";
  $("#lastAP").attr("class", "lastAP "+lastAP+"Gps");
}

function clearLocs(isPlando) {
  if(loaded == false || webServInProgress == true || init == false) {
    return;
  }
  if(isPlando == true && ! isActive("binPlando")) {
    return;
  }
  if(isPlando == false && ! isActive("binItem")) {
    return;
  }

  var msg = "Reset the locations of the Interactive VARIA ";
  if(isPlando == true) {
    msg = msg + "Plandomizer ?";
  } else {
    msg = msg + "Solver ?"
  }

  var result = confirm(msg);
  if(result == false){
    return;
  }

  resetLocsInfo();

  // reset the state server side
  ajaxCall({action: "clear", scope: "item"}, "upload");
}

function getTooltip(locName, locData, item, visited) {
    var tooltip = "<center>"+locData["name"]+"</center>";

    if("boss" in locsInfo[locName]) {
        tooltip += "<center>Boss: "+locsInfo[locName]["boss"]+"</center>";
        if(visited == true) {
            return tooltip;
        }
    }

    if(visited == true) {
        return tooltip+"<center>Item: "+item+"</center>";
    } else {
        // sequence break
        if(locData["knows"].length > 0 && locData["knows"][0] == "Sequence Break") {
            return tooltip+"<center>Sequence Break</center>"
                // debug data
                +("path" in locData ? "<br>Path: "+locData["path"] : "")
                +("distance" in locData ? "<br>Distance: "+locData["distance"] : "");
        } else {
            return tooltip
                   +"Techniques: "+(locData["knows"].length > 0 ? locData["knows"] : "None")
                   +"<br>Items: "+(locData["items"].length > 0 ? locData["items"] : "None")
                   +("comeBack" in locData && locData["comeBack"] == false ? "<br>WARNING: Can't come back" : "")
                   +("difficulty" in locData ? "<br>Difficulty: "+locData["difficulty"] : "")
                   // debug data
                   +("distance" in locData ? "<br>Distance: "+locData["distance"] : "");
        }
    }
}

var itemCount = {
  "ETank": 0,
  "Reserve": 0,
  "Missile": 0,
  "Super": 0,
  "PowerBomb": 0
}

function resetItems() {
  itemCount["ETank"] = 0;
  itemCount["Reserve"] = 0;
  itemCount["Missile"] = 0;
  itemCount["Super"] = 0;
  itemCount["PowerBomb"] = 0;

  for(var i=1; i<=14; i++) {
    document.getElementById("ETank_"+i+"_pause").style.display = "none";
  }
  for(var i=1; i<=4; i++) {
    document.getElementById("Reserve_"+i+"_pause").style.display = "none";
  }

  var items = ["Charge", "Ice", "Wave", "Spazer", "Plasma", "Varia", "Gravity", "Morph", "Bomb", "SpringBall", "ScrewAttack", "HiJump", "SpaceJump", "SpeedBooster", "Grapple", "XRayScope"];
  for(var item in items) {
    document.getElementById(items[item]+"_pause_img").style.display = "none";
  }

  if(mode != "seedless") {
    var items = ["Missile", "Super", "PowerBomb"];
    for(var item in items) {
        document.getElementById(items[item]+"_pause").style.display = "none";
    }
  }
}

var bosses = ["Kraid", "Phantoon", "Draygon", "Ridley", "MotherBrain"];
function addItem(itemName) {
  if(itemName == "Nothing" || itemName == "NoEnergy" || bosses.includes(itemName)) {
    return;
  }
  if(itemName in itemCount) {
    itemCount[itemName] += 1
    if(itemName == "Missile" || itemName == "Super" || itemName == "PowerBomb") {
      if(mode != "seedless") {
        document.getElementById(itemName+"_pause").style.display = "block";
      }
    } else {
      if(itemName == "ETank") {
        var count = Math.min(14, itemCount[itemName]);
        document.getElementById(itemName+"_"+count+"_pause").style.display = "block";
      } else {
        var count = Math.min(4, itemCount[itemName]);
        document.getElementById(itemName+"_"+count+"_pause").style.display = "block";
      }
    }
  } else {
    document.getElementById(itemName+"_pause_img").style.display = "block";
  }
}

function pad(x, n) {
  return ('' + (1000 + x)).substring(4-n, x.length);
}

function setReserveCount() {
  for(var i=1; i<=4; i++) {
    document.getElementById("reserve_"+i).style.display = "none";
  }
  document.getElementById("auto").style.display = "none";
  document.getElementById("reserve_text").style.display = "none";
  document.getElementById("reserve_0").style.display = "none";
  document.getElementById("reserve_00").style.display = "none";

  if(itemCount["Reserve"] == 0) {
    return;
  }

  document.getElementById("auto").style.display = "block";
  document.getElementById("reserve_text").style.display = "block";
  document.getElementById("reserve_0").style.display = "block";
  document.getElementById("reserve_00").style.display = "block";

  var count = Math.min(4, itemCount["Reserve"]);
  document.getElementById("reserve_"+count).style.display = "block";
}

function setItemCount(itemName) {
  var count = itemCount[itemName]*5;

  // reset everything to display none
  for(var i=0; i<=9; i++) {
    for(var j=9; j<=900; j*=10) {
      document.getElementById(itemName+"_"+j+"_"+i+"_pause").style.display = "none";
    }
  }

  if(count == 0) {
    return;
  }

  count = pad(count, 3);

  // display current count
  for(var j=9; j<=900; j*=10) {
    var i = Math.ceil(Math.log10(j));
    document.getElementById(itemName+"_"+j+"_"+count[count.length-i]+"_pause").style.display = "block";
  }

}

$(window).scroll(function(){
  $("#itemPopup").stop().animate({"marginTop": ($(window).scrollTop()) + "px"}, "fast" );
});

function clearInputSeed() {
  document.getElementById("uploadFile").value = "";
  document.getElementById("romJson").value = "";
  document.getElementById("fileName").value = "";
  if(mode != "plando") {
    document.getElementById("startLocationVisibility").style.display = "table-row";
  }
}

// https://www.w3schools.com/howto/howto_js_draggable.asp
function dragElement(elmnt, headerId) {
  var pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;
  document.getElementById(headerId).onmousedown = dragMouseDown;

  function dragMouseDown(e) {
    e = e || window.event;
    e.preventDefault();
    // get the mouse cursor position at startup:
    pos3 = e.clientX;
    pos4 = e.clientY;
    document.onmouseup = closeDragElement;
    // call a function whenever the cursor moves:
    document.onmousemove = elementDrag;
  }

  function elementDrag(e) {
    e = e || window.event;
    e.preventDefault();
    // calculate the new cursor position:
    pos1 = pos3 - e.clientX;
    pos2 = pos4 - e.clientY;
    pos3 = e.clientX;
    pos4 = e.clientY;
    // set the element's new position:
    elmnt.style.top = (elmnt.offsetTop - pos2) + "px";
    elmnt.style.left = (elmnt.offsetLeft - pos1) + "px";
  }

  function closeDragElement() {
    // stop moving when mouse button is released:
    document.onmouseup = null;
    document.onmousemove = null;
  }
}
